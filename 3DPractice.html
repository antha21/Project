<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>DOOM-Like Maze</title>
<style>
/* --- General Styles --- */
body { 
    margin: 0; 
    overflow: hidden; 
    background: #0a0a0a; /* dark, moody background */
    font-family: 'Cinzel', 'Georgia', serif; /* classy serif font */
    color: #f5e1b7; /* gold-ish text for mafia style */
}
canvas { 
    display: block; 
}

/* --- HUD & Messages --- */
#hud { 
    position: absolute; 
    top: 10px; 
    left: 10px; 
    color: #f5e1b7; 
    font-family: 'Consolas', monospace; 
    font-size: 20px; 
    z-index: 10; 
}
#msg { 
    position: absolute; 
    top: 20px; 
    left: 20px; 
    color: #f5e1b7; 
    font-family: 'Consolas', monospace; 
    font-size: 22px; 
    text-shadow: 0 0 12px #c99d4d; 
    z-index: 9; 
}

/* --- Start Menu --- */
#startMenu {
    position: absolute;
    inset: 0;

    background:
        linear-gradient(
            rgba(0,0,0,0.75),
            rgba(0,0,0,0.85)
        ),
        url("Screenshot 2025-12-21 192238.png");

    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;

    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;

    text-align: center;
    color: #f5e1b7;
    z-index: 20;

    box-shadow:
        inset 0 0 120px rgba(0,0,0,0.9),
        inset 0 0 300px rgba(0,0,0,0.6);
}


#startMenu h1 {
    font-size: 60px;
    font-weight: 900;
    text-shadow: 0 0 10px #c99d4d, 0 0 20px #000;
    margin-bottom: 30px;
    letter-spacing: 3px;
}

button {
    font-size: 26px;
    padding: 14px 40px;
    background: rgba(10,10,10,0.85);
    color: #f5e1b7;
    border: 2px solid #c99d4d;
    cursor: pointer;
    margin-top: 18px;
    border-radius: 8px;
    font-family: 'Cinzel', serif;
    letter-spacing: 3px;
    transition: all 0.25s ease;
    box-shadow: 0 0 20px rgba(0,0,0,0.6);
}

button:hover {
    background: #c99d4d;
    color: #0a0a0a;
    box-shadow: 0 0 25px rgba(201,157,77,0.9);
    transform: translateY(-2px);
}

.small { 
    font-size: 18px; 
    margin-top: 12px; 
    color: #d4b87c; 
    cursor: default; 
}

/* --- How to Play Page --- */
#howToPage {
    position: absolute;
    inset: 0;

    background:
        linear-gradient(
            rgba(0,0,0,0.85),
            rgba(0,0,0,0.9)
        ),
        url("Connect4/Screenshot 2025-12-21 192238.png");

    background-size: cover;
    background-position: center;

    display: none;
    justify-content: center;
    align-items: center;
    text-align: center;
    color: #f5e1b7;
    z-index: 25;
}


#howToPage h2 {
    font-size: 48px;
    margin-bottom: 24px;
    text-shadow: 0 0 8px #c99d4d;
}

#howToPage p {
    font-size: 22px;
    line-height: 1.6;
    max-width: 600px;
    margin: 0 auto 32px auto;
    text-shadow: 0 0 4px #000;
}

#howToPage button {
    font-size: 24px;
    padding: 12px 28px;
}

/* --- Center Text --- */
.centerText {
    position: absolute; 
    left: 50%; 
    top: 50%; 
    transform: translate(-50%, -50%);
    color: #f5e1b7; 
    font-family: 'Cinzel', serif; 
    font-size: 64px; 
    text-shadow: 0 0 20px #000, 0 0 15px #c99d4d; 
    z-index: 30;
}

.menuTitle {
    font-family: 'Cinzel', serif;
    font-size: 78px;
    font-weight: 900;
    letter-spacing: 6px;
    color: #f5e1b7;
    text-shadow:
        0 0 12px rgba(201,157,77,0.6),
        0 0 40px rgba(0,0,0,0.9);
    margin-bottom: 18px;
}

.menuSubtitle {
    font-size: 18px;
    letter-spacing: 4px;
    margin-top: 8px;
    color: #c99d4d;
    text-transform: uppercase;
    opacity: 0.9;
}

</style>
</head>
<body>

<!-- --- Start Menu --- -->
<div id="startMenu">
    <div class="menuTitle">
    The DogMother 3D
    <div class="menuSubtitle">An Offer You Canâ€™t Escape</div>
</div>

    <button id="startBtn">START</button>
    <button id="howToBtn">HOW TO PLAY</button>
</div>

<!-- --- How to Play Page --- -->
<div id="howToPage" style="display:none;">
    <div class="centerText" style="font-size:32px; max-width:600px; text-align:center;">
        <h2>HOW TO PLAY</h2>
        <p> You come to me to play my video game without bringing me any dog treats. After becoming the new DogMother for the DeShrimpo Crime Family in Scotland, the Squirrel Crime Family took action and stole 6 valuable items of Daisy's and now she needs to get them back. Collect all items and reach the getaway car to win. Watch out for enemies!</p>
	<p>Move with the ARROW keys.<br>
        Strafe with A / D.<br>
        Shoot with SPACEBAR.<br>
	Pause with P.</p>
        <button id="backBtn">BACK</button>
    </div>
</div>

<!-- --- HUD & Messages --- -->
<div id="hud"></div>
<div id="msg"></div>

<!-- --- Game Canvas --- -->
<canvas id="game"></canvas>

<!-- --- Audio --- -->
<audio id="bgMusic" loop>
    <source src="Connect4_3\Colorado Rockies - Syphon Filter 2 Soundtrack.mp3" type="audio/mpeg">
</audio>

<audio id="shootSound">
    <source src="Connect4\ytmp3free.cc_realistic-machine-gun-sound-effects-for-video-project-youtubemp3free.org.mp3" type="audio/mpeg">
</audio>
<audio id="enemyGunSound">
    <source src="Magnum 44 sound.mp4" type="audio/mp4">
</audio>

<audio id="itemPickupSound">
    <source src="Connect4/Item Pick up Counter Strike Source  Sound Effect for editing.mp3" type="audio/mpeg">
</audio>

<audio id="sndRevolver">
    <source src="Connect4\RevolverSound.mp3" type="audio/mpeg">
</audio>

<audio id="sndShotgun">
    <source src="Connect4/ShotGunShellsOST.mp3" type="audio/mpeg">
</audio>

<audio id="sndTommy">
    <source src="Connect4/TommyGunOST.mp3" type="audio/mpeg">
</audio>

<audio id="sndTurret">
    <source src="Connect4/TurretGunOST.mp3" type="audio/mpeg">
</audio>

<audio id="carEscapeSound">
    <source src="Connect4/Starting Car and Driving Off  Sound Effect for editing.mp3" type="audio/mpeg">
</audio>

<audio id="menuMusic" loop>
    <source src="Connect4_4/Love Theme From The Godfather.mp3" type="audio/mpeg">
</audio>



<script>

// Get How To elements
const howToPage = document.getElementById("howToPage");
const howToBtn = document.getElementById("howToBtn");
const backBtn = document.getElementById("backBtn");

// Show How To page
howToBtn.addEventListener("click", () => {
    startMenu.style.display = "none"; // hide start menu
    howToPage.style.display = "flex"; // show How To page
});

// Back to Start Menu
backBtn.addEventListener("click", () => {
    howToPage.style.display = "none"; // hide How To page
    startMenu.style.display = "flex"; // show start menu
});

const menuMusic = document.getElementById("menuMusic");

// Play menu music safely after user interaction
function playMenuMusic() {
    menuMusic.currentTime = 0;
    menuMusic.play().catch(() => {});
}

// Stop menu music when game starts
function stopMenuMusic() {
    menuMusic.pause();
    menuMusic.currentTime = 0;
}

// Unlock audio on first user click
document.addEventListener("click", function unlockMenuMusic() {
    if (!menuActive) return;   // ðŸš« don't play if game started

    playMenuMusic();
    document.removeEventListener("click", unlockMenuMusic);
});




// -------------------- Canvas Setup --------------------
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function resize() { 
    canvas.width = innerWidth; 
    canvas.height = innerHeight; 
}
resize();
addEventListener("resize", resize);

// -------------------- UI Elements --------------------
const startMenu = document.getElementById("startMenu");
const startBtn = document.getElementById("startBtn");
const hud = document.getElementById("hud");
const msg = document.getElementById("msg");
const bgMusic = document.getElementById("bgMusic");
const shootSound = document.getElementById("shootSound");
const enemyGunSound = document.getElementById("enemyGunSound");

const sndRevolver = document.getElementById("sndRevolver");
const sndShotgun  = document.getElementById("sndShotgun");
const sndTommy    = document.getElementById("sndTommy");
const sndTurret   = document.getElementById("sndTurret");

const carEscapeSound = document.getElementById("carEscapeSound");


const STATUS_BAR_HEIGHT = 110;
const viewHeight = canvas.height - STATUS_BAR_HEIGHT;

const STRAFE_FACTOR = 0.45; // 0.5â€“0.7 feels good

// ===== Voice / FX Sounds =====
const sndTommyTalk   = new Audio("Connect4/TommyTalk.mp3");
const sndTurretLaugh = new Audio("Connect4/TurrentLaugh.mp3");
const sndTurretDeath = new Audio("Connect4/TurretDeath.mp3");

const sndDirectHit   = new Audio("Connect4/DirectHit.mp3");
const sndRevolverTalk= new Audio("Connect4/RevolverTalk.mp3");
const sndRobotDeath  = new Audio("Connect4/RobotDeath.mp3");

// Volumes (adjust freely)
sndTommyTalk.volume    = 1.0;
sndTurretLaugh.volume  = 0.8;
sndTurretDeath.volume  = 0.9;

sndDirectHit.volume    = 0.6;
sndRevolverTalk.volume = 1.0;
sndRobotDeath.volume   = 0.9;

const enemySoundState = {
    shotgun: 0,
    tommy: 0,
    turret: 0
};

// ðŸ”Š Volume controls (easy to tweak)
sndRevolver.volume = 1.00; // adjust if needed
sndShotgun.volume  = 0.65;
sndTommy.volume    = 0.75;
sndTurret.volume   = 0.95;

// -------------------- Game State --------------------
let gameStarted = false;
let gameOver = false;
let gameWin = false;
let endTimer = 0;

let keys = {};
let shooting = false;
let mouseDelta = 0;
let fireCooldown = 0;

let tempMsg = "";
let tempMsgTimer = 0;

let menuActive = true;
let paused = false;




// -------------------- Start Game --------------------
startBtn.addEventListener("click", () => {
    menuActive = false;
    startMenu.style.display = "none";
    msg.style.display = "none";
    gameStarted = true;
    
    // Stop menu music
    stopMenuMusic();
    // ðŸ”“ Unlock all sounds
    bgMusic.currentTime = 0;
    bgMusic.play().catch(()=>{});

    itemPickupSound.play().then(() => {
        itemPickupSound.pause();
        itemPickupSound.currentTime = 0;
    }).catch(()=>{});

    [
    	sndRevolver,
    	sndShotgun,
    	sndTommy,
    	sndTurret
    ].forEach(snd => {
    	snd.play().then(() => {
        	snd.pause();
        	snd.currentTime = 0;
    }).catch(()=>{});
});


    initGame();
    initItemsAndCar();
});

<!-- ---Images --- -->
// Load health pack image
const healthPackImg = new Image();
healthPackImg.src = "Connect4_2/Screenshot 2025-12-17 150054.png";

// Load health pickup sound
const healthPickupSound = new Audio("Connect4/ytmp3free.cc_garrys-mod-health-vial-sound-effect-youtubemp3free.org.mp3");

// ========================
// Player Face Images
// ========================
const faceIdle = new Image();
faceIdle.src = "Connect4/Chump1.jpg";

const faceFire = new Image();
faceFire.src = "Connect4/Chump2.jpg";

// --- Preload car image ---
const carImg = new Image();
carImg.src = "Connect4_2/Car.jpg";

// ========================
// 1-UP Collectible
// ========================
const oneUpImg = new Image();
oneUpImg.src = "Connect4_4/Screenshot_20250615_162031_Snapchat.jpg";

// Optional sound (reuse pickup sound if you want)
const oneUpSound = new Audio(
    "Connect4/Item Pick up Counter Strike Source  Sound Effect for editing.mp3"
);
oneUpSound.volume = 0.8;



// ========================
// World Object Sizes
// ========================
const ITEM_WORLD_SIZE = 88;   // base on-screen size (pixels)
const ITEM_MIN_SIZE   = 42;   // far distance
const ITEM_MAX_SIZE   = 130;   // close distance

const FORCE_VISIBLE_DIST = 0.9; // tweak: 0.7â€“1.2

let deathFade = 0;      // 0 = fully visible, 1 = fully black
let isDead = false;
let fadeDirection = 0;  // 0 = none, 1 = fading out, -1 = fading in
const FADE_SPEED = 0.02; // adjust for faster/slower fade


// -------------------- Pointer Lock --------------------
canvas.addEventListener("click", () => canvas.requestPointerLock());
document.addEventListener("pointerlockchange", () => {
    msg.style.display = (document.pointerLockElement !== canvas && gameStarted && !gameOver && !gameWin) ? "block" : "none";
});

// -------------------- Keyboard Input & Shooting --------------------
addEventListener("keydown", e => {
    keys[e.key] = true;
    if(e.code === "Space" && !shooting) {
        shooting = true;
        shootSound.currentTime = 0;
        shootSound.loop = true;
        shootSound.play().catch(() => {});
    }
});

addEventListener("keyup", e => {
    keys[e.key] = false;
    if(e.code === "Space") {
        shooting = false;
        shootSound.pause();
        shootSound.currentTime = 0;
    }
});

// -------------------- Mouse Movement --------------------
document.addEventListener("mousemove", e => {
    if(document.pointerLockElement === canvas) mouseDelta = e.movementX;
});

// -------------------- Maze Map --------------------
const map = [
[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
[1,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1],
[1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1],
[1,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1],
[1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,1,1,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1,1,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1],
[1,0,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,0,1,1],
[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1],
[1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1],
[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1],
[1,0,1,1,1,1,1,0,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1],
[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

const MAP_W = map[0].length;
const MAP_H = map.length;

// -------------------- Player --------------------
let player = {
    x: 3.5, 
    y: 3.5, 
    angle: 0, 
    speed: 0.070, 
    health: 1000,
    lives: 3
};

// ================= HEALTH PACKS =================
let healthPacks = [
    {x: 14.5, y: 3.5, collected: false},
    {x: 2.5, y: 6.5, collected: false},
    {x: 16.5, y: 6.5, collected: false},
    {x: 24.5, y: 9.5, collected: false},
    {x: 16.5, y: 10.5, collected: false},
    {x: 23.5, y: 17.5, collected: false},
    {x: 2.5, y: 10.5, collected: false}
];

let oneUps = [
    { x: 26.5,  y: 5.5,  collected: false },
    { x: 9.5, y: 18.5, collected: false }
];


// ========================
// Object Images
// ========================
const objectImages = [
    new Image(),
    new Image(),
    new Image(),
    new Image(),
    new Image(),
    new Image()
];

objectImages[0].src = "Connect4_2/Object1 (5).jpg";
objectImages[1].src = "Connect4/Object1 (6).jpg";
objectImages[2].src = "Connect4_2/Object1 (1).jpg";
objectImages[3].src = "Connect4_2/Object1 (2).jpg";
objectImages[4].src = "Connect4_4/Object1 (3).jpg";
objectImages[5].src = "Connect4_4/Object1 (4).jpg";



// ========================
// Enemy Types
// ========================
const ENEMY_TYPES = {
    revolver: {
        sprite: "Connect4/copilot_image_1766009412260.jpeg",
        health: 100,
        moveSpeed: 0.03,
        idleSpeed: 0.015,
        shootCooldown: 60,
        bulletSpeed: 0.15,
        burst: 1,
        canMoveWhileShooting: true,
        isTurret: false,
	meleeDamage: 0.3,
        bulletDamage: 12,
	minAttackDist: 2.2
    },

    turret: {
        sprite: "Connect4_4/copilot_image_1766009643966.jpeg",
        health: 220,
        moveSpeed: 0,
        idleSpeed: 0,
        shootCooldown: 10,
        bulletSpeed: 0.18,
        burst: 1,
        canMoveWhileShooting: false,
        isTurret: true,
	meleeDamage: 0,
        bulletDamage: 15
    },

    tommy: {
        sprite: "Connect4_2/copilot_image_1766008655046.jpeg",
        health: 140,
        moveSpeed: 0.02,
        idleSpeed: 0.01,
        shootCooldown: 6,
        bulletSpeed: 0.17,
        burst: 3,
        canMoveWhileShooting: false,
        isTurret: false,
	meleeDamage: 0.4,
        bulletDamage: 8,
	minAttackDist: 2.6
    },

    shotgun: {
        sprite: "Connect4_2/copilot_image_1766009225786.jpeg",
        health: 160,
        moveSpeed: 0.03,
        idleSpeed: 0.015,
        shootCooldown: 120,
        bulletSpeed: 0.14,
        burst: 5,
        canMoveWhileShooting: true,
        isTurret: false,
        meleeDamage: 0.35,
        bulletDamage: 10,
	minAttack: 2.5
    }
};


// -------------------- Enemies --------------------
let enemies = [];

let enemiesTemplate = [
    {x:11.5, y:1.5, type:"revolver"},
    {x:23.5, y:1.5, type:"revolver"},
    {x:20.5, y:11.5, type:"revolver"},
    {x:21.5, y:13.5, type:"revolver"},
    {x:21.5, y:17.5, type:"revolver"},
    {x:2.5, y:9.5, type:"revolver"},

    {x:5.5, y:7.5, type:"shotgun"},
    {x:5.5, y:10.5, type:"shotgun"},
    {x:4.5, y:17.5, type:"shotgun"},

    {x:16.5, y:1.5, type:"tommy"},
    {x:14.5, y:7.5, type:"tommy"},
    {x:14.5, y:10.5, type:"tommy"},
    {x:14.5, y:18.5, type:"tommy"},

    {x:26.5, y:3.5, type:"turret"},
    {x:24.5, y:10.5, type:"turret"},
    {x:8.5, y:18.5, type:"turret"},
    {x:10.5, y:18.5, type:"turret"}
];

enemies = enemiesTemplate.map(e => ({
    ...e,
    alive: true,
    health: ENEMY_TYPES[e.type].health,
    shootCooldown: 0,
    shootingSound: false,
    state: "idle",
    dir: Math.random()*Math.PI*2,
    stateTimer: 0
}));

// -------------------- Enemy Sprite --------------------
const enemySprites = {};

Object.keys(ENEMY_TYPES).forEach(type => {
    const img = new Image();
    img.src = ENEMY_TYPES[type].sprite;
    enemySprites[type] = img;
});

// -------------------- Bullets --------------------
let bullets = [];
let enemyBullets = [];

// -------------------- Items & Car --------------------
let items = [];
let car = null;

    

function initItemsAndCar() {
    items = [
        { x:26.5, y:1.5, collected:false, img: objectImages[0] },
    	{ x:12.5, y:3.5, collected:false, img: objectImages[2] },
    	{ x:19.5, y:5.5, collected:false, img: objectImages[1] },
    	{ x:11.5, y:13.5, collected:false, img: objectImages[3] },
    	{ x:26.5, y:17.5, collected:false, img: objectImages[4] },
    	{ x:1.5, y:18.5, collected:false, img: objectImages[5] }
    ];	
    car = {x:1.5, y:1.5};
}

let collectedMessageShown = false;

function collectItems() {
    items.forEach(item => {
        if(item.collected) return;

        const dist = Math.hypot(player.x - item.x, player.y - item.y);
        if(dist < 0.5){
            item.collected = true;

            itemPickupSound.currentTime = 0;
            itemPickupSound.play();

            showTempMessage("Item Collected!", 60);
        }
    });

    // Show "all collected" message only once
    if(items.every(i => i.collected) && !collectedMessageShown){
        showTempMessage("All items collected! Head to the car!", 120);
        collectedMessageShown = true;
    }
}



function showTempMessage(msg, duration=120){
    tempMsg = msg;
    tempMsgTimer = duration;
}

let carWarningShown = false;

function checkCarEscape() {
    const distToCar = Math.hypot(player.x - car.x, player.y - car.y);
    if(items.every(it => it.collected) && distToCar < 1) {
        if(!gameWin){
            gameWin = true;
            endTimer = 900;
	    
            carEscapeSound.currentTime = 0;
	    carEscapeSound.play().catch(() => {});
        }
    } else if(distToCar < 1 && !items.every(it => it.collected)) {
        if(!carWarningShown) {
            showTempMessage("Collect all items before escaping!", 120);
            carWarningShown = true;
        }
    } else {
        carWarningShown = false;
    }
}

// --- Draw items & car on mini-map ---
function drawItemsAndCar() {
    const scale = 15;
    const offsetX = canvas.width - MAP_W * scale - 20;
    const offsetY = canvas.height - MAP_H * scale - 20;

    items.forEach(item => {
        if(!item.collected){
            ctx.fillStyle = "yellow";
            ctx.fillRect(offsetX + item.x * scale - 3, offsetY + item.y * scale - 3, 6, 6);
        }
    });

    if(car){
        if(carImg.complete){
            ctx.drawImage(carImg, offsetX + car.x * scale - 5, offsetY + car.y * scale - 5, 10, 10);
        } else {
            ctx.fillStyle = "cyan";
            ctx.fillRect(offsetX + car.x * scale - 3, offsetY + car.y * scale - 3, 6, 6);
        }
    }
}


// --- Draw items & car in 3D world ---
function drawItemsAndCar3D(zBuffer){
    const w = canvas.width;
    const h = canvas.height;

    // --- Draw collectibles (unchanged) ---
    items.forEach(item => {
        if(item.collected) return;

        const dx = item.x - player.x;
        const dy = item.y - player.y;
        const dist = Math.hypot(dx, dy);

        if(dist > 60) return;
        if(!canSee(player.x, player.y, item.x, item.y)) return;

        let ang = Math.atan2(dy, dx) - player.angle;
        ang = Math.atan2(Math.sin(ang), Math.cos(ang));

        if(Math.abs(ang) < Math.PI / 2){
            let size = ITEM_WORLD_SIZE * (6 / dist);
            size = Math.min(ITEM_MAX_SIZE, size);
            size = Math.max(ITEM_MIN_SIZE, size);

            const screenX = w / 2 + Math.tan(ang) * w / 2;

            ctx.save();
            ctx.shadowBlur = 18;
            ctx.shadowColor = "rgba(255, 255, 200, 0.85)";

            ctx.drawImage(
                item.img,
                screenX - size / 2,
                h / 2 - size / 2,
                size,
                size
            );

            ctx.restore();
        }
    });

    // --- Draw car (spaceship-style) ---
    if(car && carImg.complete){
        let dx = (car.x + 0.5) - player.x;
        let dy = (car.y + 0.5) - player.y;
        let dist = Math.hypot(dx, dy);
        let ang = Math.atan2(dy, dx) - player.angle;

        ang = Math.atan2(Math.sin(ang), Math.cos(ang));

        const FORCE_VISIBLE_DIST = 0.4;
        const forceVisible = dist < FORCE_VISIBLE_DIST + 0.4;

        if(!forceVisible && Math.abs(ang) > Math.PI/2 + 0.02) return;

        const sx = w/2 + Math.tan(ang) * w/2;
        if(!forceVisible && (sx < 0 || sx >= w)) return;

        const idx = Math.max(0, Math.min(Math.floor(sx), zBuffer.length - 1));
        if(!forceVisible && zBuffer[idx] < dist) return;

        const sz = Math.max(h / Math.max(dist, 0.3) * 1.2, 100); // bigger car
        if(typeof isFullyVisible === "function" && !isFullyVisible(dist, sx, sz, zBuffer)) return;

        ctx.save();
        ctx.shadowBlur = 28;
        ctx.shadowColor = "#00ffff"; // cyan glow
        ctx.drawImage(
            carImg,
            sx - sz/2,
            h/2 - sz/2,
            sz,
            sz
        );
        ctx.restore();
    }
}


// ------------------Player------------------------

function createPlayer() {
    return {
        x: 3.5,
        y: 3.5,
        angle: 0,
        speed: 0.070,
        health: 1000,
        lives: 3
    };
}


// ========================
// Wall Textures
// ========================
function makeTexture(c1, c2){
    let cnv = document.createElement("canvas"); 
    cnv.width = cnv.height = 32;
    let cctx = cnv.getContext("2d");
    cctx.fillStyle = c1; 
    cctx.fillRect(0, 0, 32, 32);
    cctx.strokeStyle = c2; 
    cctx.lineWidth = 4;
    for(let x = 0; x < 32; x += 8){ 
        cctx.beginPath(); 
        cctx.moveTo(x, 0); 
        cctx.lineTo(32, 32 - x); 
        cctx.stroke(); 
    }
    return ctx.createPattern(cnv, "repeat");
}
const wallTextures = [
    makeTexture("#334", "#556"),
    makeTexture("#552", "#aa4"),
    makeTexture("#400", "#a00")
];

// ------Pausing----------

function pauseGame() {
    if (paused) return;
    paused = true;

    // Stop all sounds
    stopAllSounds();

    // DO NOT exit pointer lock
    // (keeps screen locked)

    msg.innerText = "PAUSED";
    msg.style.display = "block";
}

function resumeGame() {
    if (!paused) return;
    paused = false;

    // Resume ONLY game music
    bgMusic.play().catch(()=>{});

    // Pointer lock remains active

    msg.innerText = "";
}

addEventListener("keydown", e => {

    if (e.key === "p" || e.key === "P") {
        if (!gameStarted || gameOver || gameWin) return;
        paused ? resumeGame() : pauseGame();
        return;
    }

    if (paused) return;

    keys[e.key] = true;

    if (e.code === "Space" && !shooting) {
        shooting = true;
        shootSound.currentTime = 0;
        shootSound.loop = true;
        shootSound.play().catch(()=>{});
    }
});


// ========================
// Raycasting
// ========================
let zBuffer = new Array(canvas.width);

function castRays(){
    const w = canvas.width, h = canvas.height;
    ctx.fillStyle = "#222244"; ctx.fillRect(0, 0, w, h/2);
    ctx.fillStyle = "#111"; ctx.fillRect(0, h/2, w, h/2);

    const fov = Math.PI/3, step = fov / w;

    for(let i = 0; i < w; i++){
        const angle = player.angle - fov/2 + step*i;
        let dist = 0, hit = false, cellValue = 1;

        while(!hit && dist < 20){
            dist += 0.02;
            const rx = player.x + Math.cos(angle) * dist;
            const ry = player.y + Math.sin(angle) * dist;
            const mx = Math.floor(rx), my = Math.floor(ry);

            if(mx < 0 || my < 0 || mx >= MAP_W || my >= MAP_H){
                hit = true; cellValue = 1; break;
            }

            cellValue = map[my][mx];
            if(cellValue !== 0) hit = true;
        }

        zBuffer[i] = dist; // store distance for this column

        let wallH = Math.min(h, 600 / dist);
        if(!isFinite(wallH)) wallH = h;

        const texture = wallTextures[cellValue % wallTextures.length];
        ctx.fillStyle = texture;
        ctx.fillRect(i, (h - wallH)/2, 1, wallH);
        ctx.fillStyle = `rgba(0,0,0,${dist/12})`;
        ctx.fillRect(i, (h - wallH)/2, 1, wallH);
    }
}

// ========================
// Line-of-Sight
// ========================
function canSee(px, py, ex, ey){
    const dx = ex - px;
    const dy = ey - py;
    const dist = Math.hypot(dx, dy);
    const steps = dist / 0.05; // check every 0.05 units
    for(let i = 0; i <= steps; i++){
        const t = i / steps;
        const x = px + dx * t;
        const y = py + dy * t;
        const mx = Math.floor(x);
        const my = Math.floor(y);
        if(mx < 0 || my < 0 || mx >= MAP_W || my >= MAP_H) return false;
        if(map[my][mx] === 1) return false;
    }
    return true;
}


function canSeeSoft(px, py, ex, ey, radius = 0.45){
    // Check center and four points around enemy
    const points = [
        [ex, ey],
        [ex + radius, ey],
        [ex - radius, ey],
        [ex, ey + radius],
        [ex, ey - radius]
    ];

    for(let [tx, ty] of points){
        if(canSee(px, py, tx, ty)){
            return true; // if any point is visible, enemy is visible
        }
    }
    return false;
}

// ========================
// Enemy Functions
// ========================
function eAngle(e){
    return Math.atan2(player.y - e.y, player.x - e.x);
}

function enemyShoot(e){
    const cfg = ENEMY_TYPES[e.type];

    e.didShootThisFrame = true; 

    for(let i = 0; i < cfg.burst; i++){
        let spread = 0;
        if(e.type === "shotgun"){
            spread = (Math.random() - 0.5) * 0.4;
        }

        const dx = player.x - e.x;
        const dy = player.y - e.y;
        const baseAngle = Math.atan2(dy, dx) + spread;

        enemyBullets.push({
            x: e.x,
            y: e.y,
            vx: Math.cos(baseAngle) * cfg.bulletSpeed,
            vy: Math.sin(baseAngle) * cfg.bulletSpeed,
            life: 80
        });
    }

    // ðŸ”Š Play revolver immediately
    if(e.type === "revolver" && sndRevolver){
        sndRevolver.currentTime = 0;
        sndRevolver.play().catch(()=>{}); 
    }
}

function drawEnemies() {
    const w = canvas.width, h = canvas.height;

    // Update all enemies (AI, movement, shooting, sound)
    enemies.forEach(e => {
        if (!e.alive) {
            stopEnemySound(e);
            return;
        }

        e.didShootThisFrame = false;
        const cfg = ENEMY_TYPES[e.type];
        let dx = e.x - player.x;
        let dy = e.y - player.y;
        let dist = Math.hypot(dx, dy);
        let moveDist = Math.max(dist, 0.001);

        // Melee
        if (!cfg.isTurret && dist < 0.8 && e.meleeCooldown <= 0) {
            player.health -= cfg.meleeDamage;
            player.health = Math.max(0, player.health);
            e.meleeCooldown = 20;
        }
        if (e.meleeCooldown > 0) e.meleeCooldown--;

        // Hard separation
        const minSeparation = 0.6;
        if (dist < minSeparation) {
            const push = (minSeparation - dist) * 0.5;
            const nx = e.x + (dx / moveDist) * push;
            const ny = e.y + (dy / moveDist) * push;
            if (mxValid(nx, ny) && map[Math.floor(ny)][Math.floor(nx)] === 0) {
                e.x = nx; e.y = ny;
            }
        }

        // AI state
        if (canSee(e.x, e.y, player.x, player.y)) {
            e.state = "chase";
            e.stateTimer = 120;
        } else if (e.stateTimer > 0) {
            e.stateTimer--;
        } else {
            e.state = "idle";
        }

        // Idle move
        if (e.state === "idle" && !cfg.isTurret) {
            const step = cfg.idleSpeed;
            if (Math.random() < 0.01) e.dir = Math.random() * Math.PI * 2;
            const nx = e.x + Math.cos(e.dir) * step;
            const ny = e.y + Math.sin(e.dir) * step;
            if (mxValid(nx, ny) && map[Math.floor(ny)][Math.floor(nx)] === 0) {
                e.x = nx; e.y = ny;
            } else e.dir += Math.PI / 2;
        }

        // Chase move
        if (e.state === "chase" && !cfg.isTurret) {
            const stopDist = cfg.minAttackDist || 1.2;
            if (dist > stopDist && (cfg.canMoveWhileShooting || e.shootCooldown <= 0)) {
                const step = cfg.moveSpeed;
                const nx = e.x - (dx / moveDist) * step;
                const ny = e.y - (dy / moveDist) * step;
                if (mxValid(nx, ny) && map[Math.floor(ny)][Math.floor(nx)] === 0) {
                    e.x = nx; e.y = ny;
                }
            }
        }

        // Shooting
        if (canSee(e.x, e.y, player.x, player.y) && e.shootCooldown <= 0) {
            enemyShoot(e);
            e.shootCooldown = cfg.shootCooldown;
        }
        if (e.shootCooldown > 0) e.shootCooldown--;

        // Sound control
        const seesPlayer = canSee(e.x, e.y, player.x, player.y);
        if (e.alive) {
            if (seesPlayer) {
                if (e.type !== "revolver") playEnemySound(e);
                e.soundTimer = 100;
            } else if (e.soundTimer > 0) e.soundTimer--;
            else stopEnemySound(e);
        } else stopEnemySound(e);

        // First sight voice
        if (seesPlayer && !e.wasSeeingPlayer) {
            switch (e.type) {
                case "tommy": sndTommyTalk.currentTime = 0; sndTommyTalk.play().catch(() => {}); break;
                case "turret": sndTurretLaugh.currentTime = 0; sndTurretLaugh.play().catch(() => {}); break;
                case "revolver": sndRevolverTalk.currentTime = 0; sndRevolverTalk.play().catch(() => {}); break;
            }
        }
        e.wasSeeingPlayer = seesPlayer;

        e.dist = dist; // store for rendering
    });

    // Sort enemies by distance farthest first (closest drawn last)
    const drawList = enemies
        .filter(e => e.alive)
        .sort((a, b) => b.dist - a.dist);

    // Rendering
    drawList.forEach(e => {
        let dx = e.x - player.x;
        let dy = e.y - player.y;
        let dist = Math.max(e.dist, 0.35); // min render distance
        let angleToEnemy = Math.atan2(dy, dx) - player.angle;
        angleToEnemy = Math.atan2(Math.sin(angleToEnemy), Math.cos(angleToEnemy));

        const halfFov = Math.PI / 3;
        const fovBuffer = 0.12;
        if (Math.abs(angleToEnemy) > halfFov + fovBuffer) return;

        let screenX = w / 2 + Math.tan(angleToEnemy) * w / 2;
        if (!isFinite(screenX)) return;

        const column = Math.max(0, Math.min(Math.floor(screenX), zBuffer.length - 1));
        if (dist > zBuffer[column] + 0.15) return; // wall closer

        // Size calculation
        let size = (h / Math.max(dist, 0.1)) * 0.9;
        const farDist = 10;
        size *= Math.pow(Math.min(1, farDist / dist), 0.8);
        size = Math.max(size, 24);

        // Shadow
        ctx.fillStyle = "rgba(0,0,0,0.35)";
        ctx.beginPath();
        ctx.ellipse(screenX, h/2 + size*0.9, size*0.4, size*0.35, 0, 0, Math.PI*2);
        ctx.fill();

        // Draw sprite
        const img = enemySprites[e.type];
        if (img && img.complete) ctx.drawImage(img, screenX - size/2, h/2 - size, size, size*2);
        else {
            ctx.fillStyle = "red";
            ctx.fillRect(screenX - size/4, h/2 - size, size/2, size*2);
        }

        // Health bar
        const hbW = size, hbX = screenX - hbW/2, hbY = h/2 - size - 16;
        ctx.fillStyle = "black";
        ctx.fillRect(hbX-1, hbY-1, hbW+2, 12);
        ctx.fillStyle = "lime";
        ctx.fillRect(hbX, hbY, hbW * (e.health / ENEMY_TYPES[e.type].health), 10);
    });
}


function playEnemySound(e){
    let snd;

    switch(e.type){
        case "revolver": snd = sndRevolver; break;
        case "shotgun":  snd = sndShotgun;  break;
        case "tommy":    snd = sndTommy;    break;
        case "turret":   snd = sndTurret;   break;
    }

    if(!snd) return;

    // Single-shot weapon
    if(e.type === "revolver"){
        snd.currentTime = 0;
        snd.play().catch(()=>{});
        return;
    }

    // Automatic / looped weapons
    if(!e.shootingSound){
        snd.loop = true;
        snd.play().catch(()=>{});
        e.shootingSound = true;
    }
}

function stopEnemySound(e){
    let snd;

    switch(e.type){
        case "shotgun": snd = sndShotgun; break;
        case "tommy":   snd = sndTommy;   break;
        case "turret":  snd = sndTurret;  break;
        default: return;
    }

    if(e.shootingSound){
        snd.pause();
        snd.currentTime = 0;
        snd.loop = false;
        e.shootingSound = false;
    }
}




// ========================
// Player Bullets
// ========================
function shootEnemies(){
    if(shootSound.paused) shootSound.play().catch(()=>{});
    const b = { 
        x: player.x + Math.cos(player.angle) * 0.2, 
        y: player.y + Math.sin(player.angle) * 0.2, 
        angle: player.angle, 
        speed: 0.28, 
        life: 90 
    };
    bullets.push(b);
}

function updateBullets(){
    bullets.forEach(b=>{
        if(b.life <= 0) return;
        b.x += Math.cos(b.angle) * b.speed;
        b.y += Math.sin(b.angle) * b.speed;
        b.life--;

        const mx = Math.floor(b.x), my = Math.floor(b.y);
        if(mx < 0 || my < 0 || mx >= MAP_W || my >= MAP_H || map[my][mx] === 1){
            b.life = 0;
            return;
        }

        enemies.forEach(e=>{
            if(!e.alive) return;
            const d = Math.hypot(e.x - b.x, e.y - b.y);
            if(d < 0.45){
    e.health -= 34;

    // ðŸ”Š HIT SOUND
    sndDirectHit.currentTime = 0;
    sndDirectHit.play().catch(()=>{});

    b.life = 0;

    if(e.health <= 0){
        e.alive = false;
        handleEnemyDeath(e);
    }
}
        });
    });
    bullets = bullets.filter(b => b.life > 0);
}

function drawBullets(){
    const w = canvas.width, h = canvas.height;

    bullets.forEach(b=>{
        let dx = b.x - player.x, dy = b.y - player.y;
        let dist = Math.hypot(dx, dy);
        if(dist < 0.4 || dist > 60) return;

        let angleToBullet = Math.atan2(dy, dx) - player.angle;
        if(angleToBullet > Math.PI) angleToBullet -= 2*Math.PI;
        if(angleToBullet < -Math.PI) angleToBullet += 2*Math.PI;

        if(Math.abs(angleToBullet) < Math.PI/2){
            let size = (h / Math.max(dist,0.1)) * 0.04;
            size = Math.min(12, Math.max(2, size));
            const screenX = w/2 + Math.tan(angleToBullet) * w/2;
            ctx.fillStyle = "yellow";
            ctx.fillRect(screenX - 2, h/2 - size/2, 4, 4 + size*0.6);
        }
    });
}

function handleEnemyDeath(e){
    // Stop weapon sounds immediately
    stopEnemySound(e);

    // Reset voice state
    e.hasSpoken = false;
    e.wasSeeingPlayer = false;

    // Death sounds
    if(e.type === "turret"){
        sndTurretDeath.currentTime = 0;
        sndTurretDeath.play().catch(()=>{});
    } else {
        sndRobotDeath.currentTime = 0;
        sndRobotDeath.play().catch(()=>{});
    }
}

// ========================
// Enemy Bullets
// ========================
function updateEnemyBullets(){
    enemyBullets.forEach(b=>{
        if(b.life <= 0) return;
        b.x += b.vx; b.y += b.vy; b.life--;

        const mx = Math.floor(b.x), my = Math.floor(b.y);
        if(mx < 0 || my < 0 || mx >= MAP_W || my >= MAP_H || map[my][mx] === 1){
            b.life = 0; 
            return;
        }

        // Calculate distance to player
        const dx = b.x - player.x;
        const dy = b.y - player.y;
        if(dx*dx + dy*dy < 0.16){
            player.health -= b.damage || 10; // assign damage when bullet is created
            b.life = 0;
            if(player.health < 0) player.health = 0;
        }
    });
    enemyBullets = enemyBullets.filter(b => b.life > 0);
}


function drawEnemyBullets(){
    const w = canvas.width, h = canvas.height;

    enemyBullets.forEach(b=>{
        let dx = b.x - player.x, dy = b.y - player.y;
        let dist = Math.hypot(dx, dy);
        if(dist < 0.3 || dist > 60) return;

        let angleToBullet = Math.atan2(dy, dx) - player.angle;
        if(angleToBullet > Math.PI) angleToBullet -= 2*Math.PI;
        if(angleToBullet < -Math.PI) angleToBullet += 2*Math.PI;

        if(Math.abs(angleToBullet) < Math.PI/2){
            let size = (h / Math.max(dist,0.1)) * 0.06;
            size = Math.min(20, Math.max(2, size));
            const screenX = w/2 + Math.tan(angleToBullet) * w/2;
            ctx.fillStyle = "orange";
            ctx.fillRect(screenX - 2, h/2 - size/2, 4, 4 + size*0.6);
        }
    });
}

// ========================
// Player Movement
// ========================
function movePlayer(){
    // Rotation
    if(keys["ArrowLeft"])  player.angle -= 0.0375;
    if(keys["ArrowRight"]) player.angle += 0.0375;

    player.angle += mouseDelta * 0.002;
    mouseDelta = 0;

    const c = Math.cos(player.angle);
    const s = Math.sin(player.angle);

    let moveX = 0;
    let moveY = 0;
    
    // Forward / backward
    if(keys["ArrowUp"]){
        moveX += c * player.speed;
        moveY += s * player.speed;
    }
    if(keys["ArrowDown"]){
        moveX -= c * player.speed;
        moveY -= s * player.speed;
    }

    // Strafing (scaled immediately)
    if(keys["d"]){ // left
        moveX -= s * player.speed * STRAFE_FACTOR;
        moveY += c * player.speed * STRAFE_FACTOR;
    }
    if(keys["a"]){ // right
        moveX += s * player.speed * STRAFE_FACTOR;
        moveY -= c * player.speed * STRAFE_FACTOR;
    }

    // Collision (split-axis = smooth sliding)
    if(mxValid(player.x + moveX, player.y) &&
       map[Math.floor(player.y)][Math.floor(player.x + moveX)] !== 1){
        player.x += moveX;
    }
    if(mxValid(player.x, player.y + moveY) &&
       map[Math.floor(player.y + moveY)][Math.floor(player.x)] !== 1){
        player.y += moveY;
    }
}


function mxValid(x, y){ 
    const mx = Math.floor(x), my = Math.floor(y); 
    return !(mx < 0 || my < 0 || mx >= MAP_W || my >= MAP_H); 
}

// ========================
// Gun Rendering
// ========================
function drawGun(){
    const w = canvas.width, h = canvas.height;
    ctx.fillStyle="#444"; ctx.fillRect(w/2-40,h-150,80,150);
    ctx.fillStyle="#999"; ctx.fillRect(w/2-10,h-200,20,50);
    ctx.fillStyle="#000"; ctx.fillRect(w/2-6,h-195,12,20);
    if(shooting){ ctx.fillStyle="yellow"; ctx.fillRect(w/2-5,h-205,10,15); }
}

// ========================
// Health Packs
// ========================

function collectHealthPacks() {
    healthPacks.forEach(pack => {
        if(pack.collected) return;

        const dx = player.x - pack.x;
        const dy = player.y - pack.y;
        const dist = Math.hypot(dx, dy);

        // Collect if close enough
        if(dist < 0.5){
            player.health = Math.min(player.health + 150, 1000); // max health cap
            pack.collected = true;

            // Play sound
            healthPickupSound.currentTime = 0;
            healthPickupSound.play();

            showTempMessage("Health Restored!", 90);
        }
    });
}


function drawHealthPacks2D() {
    const scale = 15;
    const offsetX = canvas.width - MAP_W*scale - 20;
    const offsetY = canvas.height - MAP_H*scale - 20;

    healthPacks.forEach(pack => {
        if(pack.collected) return;
        if(!healthPackImg.complete) return; // only draw if loaded

        ctx.drawImage(
            healthPackImg,
            offsetX + pack.x*scale - 4, // center the icon
            offsetY + pack.y*scale - 4,
            8, 8
        );
    });
}


function drawHealthPacks3D() {
    const w = canvas.width;
    const h = canvas.height;

    healthPacks.forEach(pack => {
        if(pack.collected) return;

        const dx = pack.x - player.x;
        const dy = pack.y - player.y;
        const dist = Math.hypot(dx, dy);

        if(dist > 60) return;
        if(!canSee(player.x, player.y, pack.x, pack.y)) return;

        let ang = Math.atan2(dy, dx) - player.angle;
        ang = Math.atan2(Math.sin(ang), Math.cos(ang));

        if(Math.abs(ang) < Math.PI / 2){
            // âœ… Correct world-anchored size
            let size = 420 / dist;
            size = Math.min(size, 196);
            size = Math.max(size, 24);

            const screenX = w / 2 + Math.tan(ang) * w / 2;

            ctx.save();

            // â„ï¸ Frosty blue glow (kept)
            ctx.shadowBlur = 22 + Math.sin(performance.now() * 0.004) * 6;
            ctx.shadowColor = "rgba(120, 200, 255, 0.9)";

            ctx.drawImage(
                healthPackImg,
                screenX - size / 2,
                h / 2 - size / 2,
                size,
                size
            );

            ctx.restore();
        }
    });
}



// ========================
// Mini-map
// ========================
function drawMiniMap(){
    const scale = 15, offsetX = canvas.width - MAP_W*scale - 20, offsetY = canvas.height - MAP_H*scale - 20;
    
    // Background
    ctx.fillStyle = "rgba(0,0,0,0.5)"; 
    ctx.fillRect(offsetX-2, offsetY-2, MAP_W*scale+4, MAP_H*scale+4);

    // Map walls
    for(let y=0; y<MAP_H; y++){
        for(let x=0; x<MAP_W; x++){
            ctx.fillStyle = map[y][x] === 1 ? "#888" : "rgba(0,0,0,0)";
            ctx.fillRect(offsetX + x*scale, offsetY + y*scale, scale, scale);
        }
    }

    // Enemies
    enemies.forEach(e => {
        if(e.alive){
            ctx.fillStyle = "red";
            ctx.fillRect(offsetX + e.x*scale - 2, offsetY + e.y*scale - 2, 4, 4);
        }
    });

    // Enemy bullets
    enemyBullets.forEach(b => {
        ctx.fillStyle = "orange";
        ctx.fillRect(offsetX + b.x*scale - 1, offsetY + b.y*scale - 1, 2, 2);
    });

    
    // Player
    ctx.fillStyle = "cyan"; 
    ctx.fillRect(offsetX + player.x*scale - 3, offsetY + player.y*scale - 3, 6, 6);
}

// ------------------BAR-------------------

function drawStatusBar() {
    const w = canvas.width;
    const h = canvas.height;
    const barY = h - STATUS_BAR_HEIGHT;

    // --- Background ---
    ctx.fillStyle = "#3a2a4a"; // dark background
    ctx.fillRect(0, barY, w, STATUS_BAR_HEIGHT);

    // --- Border ---
    ctx.strokeStyle = "#0ff";
    ctx.lineWidth = 3; // slightly thicker for visibility
    ctx.strokeRect(0, barY, w, STATUS_BAR_HEIGHT);

    ctx.textBaseline = "middle";
    ctx.font = "28px Consolas"; // bigger letters

    // --- Items / Ammo (Left) ---
    const collected = items.filter(i => i.collected).length;
    ctx.fillStyle = "#0ff";
    ctx.fillText(`ITEMS: ${collected}/${items.length}`, 30, barY + 35); // moved slightly down

    // --- Health (Right) ---
    ctx.fillStyle = "#f00"; // classic red
    ctx.fillText(`HEALTH: ${Math.max(0, Math.round(player.health))}`, w - 260, barY + 35);

    // --- Lives / 1-UP (Right) ---
    ctx.fillStyle = "#0f0"; // green
    ctx.fillText(`LIVES: ${player.lives}`, w - 260, barY + 75);

    // --- Player Face (Center) ---
    const faceSize = 90; // bigger face
    const faceX = w / 2 - faceSize / 2;
    const faceY = barY + 10;
    const faceImg = shooting ? faceFire : faceIdle;

    if (faceImg.complete) {
        ctx.drawImage(faceImg, faceX, faceY, faceSize, faceSize);
    }

    // --- Face frame ---
    ctx.strokeStyle = "#0ff";
    ctx.lineWidth = 3;
    ctx.strokeRect(faceX - 2, faceY - 2, faceSize + 4, faceSize + 4);
}


// --------------------OneUPs------------------

function collectOneUps() {
    oneUps.forEach(up => {
        if (up.collected) return;

        const dx = player.x - up.x;
        const dy = player.y - up.y;
        const dist = Math.hypot(dx, dy);

        if (dist < 0.5) {
            up.collected = true;
            player.lives++;

            oneUpSound.currentTime = 0;
            oneUpSound.play().catch(()=>{});

            showTempMessage("1-UP!", 90);
        }
    });
}

function drawOneUps3D() {
    const w = canvas.width;
    const h = canvas.height;

    oneUps.forEach(up => {
        if (up.collected) return;

        const dx = up.x - player.x;
        const dy = up.y - player.y;
        const dist = Math.hypot(dx, dy);

        if (dist > 60) return;
        if (!canSee(player.x, player.y, up.x, up.y)) return;

        let ang = Math.atan2(dy, dx) - player.angle;
        ang = Math.atan2(Math.sin(ang), Math.cos(ang));

        if (Math.abs(ang) < Math.PI / 2) {
            let size = 420 / dist;
            size = Math.min(size, 160);
            size = Math.max(size, 32);

            const screenX = w / 2 + Math.tan(ang) * w / 2;

            ctx.save();

            // Green glow = classic 1-UP vibe
            ctx.shadowBlur = 24;
            ctx.shadowColor = "rgba(0,255,120,0.9)";

            ctx.drawImage(
                oneUpImg,
                screenX - size / 2,
                h / 2 - size / 2,
                size,
                size
            );

            ctx.restore();
        }
    });
}

function drawOneUps2D() {
    const scale = 15;
    const offsetX = canvas.width - MAP_W * scale - 20;
    const offsetY = canvas.height - MAP_H * scale - 20;

    oneUps.forEach(up => {
        if (up.collected) return;
        ctx.fillStyle = "lime";
        ctx.fillRect(
            offsetX + up.x * scale - 2,
            offsetY + up.y * scale - 2,
            4, 4
        );
    });
}


// ========================
// HUD
// ========================
function updateHUD(){ 
    const collected = items.filter(it => it.collected).length;
    const total = items.length;
}

// ========================
// End Conditions
// ========================
function checkEndConditions() {
    if (player.health <= 0 && !gameOver && !gameWin) {

        player.lives--;

        if (player.lives > 0) {
            // Respawn player ONLY
            player.health = 1000;
            player.x = 3.5;
            player.y = 3.5;
            player.angle = 0;

            bullets = [];
            enemyBullets = [];

        } else {
            gameOver = true;
            endTimer = 120;
        }
    }

    collectItems();
    checkCarEscape();
}

function drawEndOverlay(){
    if(!gameOver && !gameWin) return;

    // Stop all sounds immediately when overlay appears
    stopAllSounds();

    const w = canvas.width, h = canvas.height;
    ctx.save(); 
    ctx.textAlign="center";

    if(gameOver){
        ctx.fillStyle="rgba(0,0,0,0.6)";
        ctx.fillRect(w/2-300,h/2-80,600,160);
        ctx.fillStyle="red";
        ctx.font="72px Consolas";
        ctx.fillText("GAME OVER", w/2, h/2-10);
        ctx.font="20px Consolas";
        ctx.fillStyle="#f88";
        ctx.fillText("Returning to menu...", w/2, h/2+36);
    }

    if(gameWin){
        ctx.fillStyle="rgba(0,0,0,0.6)";
        ctx.fillRect(w/2-300,h/2-80,600,160);
        ctx.fillStyle="lime";
        ctx.font="72px Consolas";
        ctx.fillText("CONGRATS!", w/2, h/2-10);
        ctx.font="20px Consolas";
        ctx.fillStyle="#bdf";
        ctx.fillText("All items collected! Code: TFTI", w/2, h/2+36);
    }

    ctx.restore();
    endTimer--; 
    if(endTimer <= 0) resetToMenu();
}

// ========================
// Reset / Init
// ========================

// Reset / init
function resetToMenu() {
    try {
        bgMusic.pause();
        bgMusic.currentTime = 0;
    } catch(e){}

    gameStarted = false;
    gameOver = false;
    gameWin = false;
    endTimer = 0;

    bullets = [];
    enemyBullets = [];

    hud.innerText = "";
    startMenu.style.display = "flex";
    msg.style.display = "block";

    if (document.pointerLockElement === canvas) {
        document.exitPointerLock?.();
    }
    playMenuMusic();
}

function initGame() {
    player = createPlayer();

    bullets = [];
    enemyBullets = [];

    initEnemies();       // enemies reset ONLY here
    initItemsAndCar();   // items reset ONLY here
    resetPickups();

    gameOver = false;
    gameWin = false;
    endTimer = 0;
}

function initEnemies(){
    enemies = enemiesTemplate.map(e => ({
        ...e,
        alive: true,
        health: ENEMY_TYPES[e.type].health,
        shootCooldown: 0,
        state: "idle",
        dir: Math.random() * Math.PI * 2,
        stateTimer: 0
    }));
}

// ============================
// Stop All Sounds Function
// ============================
function stopAllSounds() {
    // Music
    bgMusic.pause();
    bgMusic.currentTime = 0;

    // Gun sounds
    [shootSound, enemyGunSound, sndRevolver, sndShotgun, sndTommy, sndTurret].forEach(snd => {
        snd.pause();
        snd.currentTime = 0;
    });

    // Voice / FX sounds
    [sndTommyTalk, sndTurretLaugh, sndTurretDeath, sndDirectHit, sndRevolverTalk, sndRobotDeath, itemPickupSound, healthPickupSound, oneUpSound].forEach(snd => {
        snd.pause();
        snd.currentTime = 0;
    });
}

function resetPickups() {
    healthPacks.forEach(pack => pack.collected = false);
    oneUps.forEach(oneUp => oneUp.collected = false);
}


// ============================
// Call when ending the game
// ============================
function handleGameEnd() {
    stopAllSounds(); // stop everything immediately
    gameStarted = false; // ensure the game is marked as not running
}

// ============================
// Integrate into your existing code
// ============================

// When player dies and no lives remain:
if(gameOver) handleGameEnd();

// When player wins:
if(gameWin) handleGameEnd();

// When returning to menu:
function resetToMenu() {
    stopAllSounds(); // stop all sounds immediately
    gameStarted = false;
    gameOver = false;
    gameWin = false;
    endTimer = 0;

    bullets = [];
    enemyBullets = [];

    hud.innerText = "";
    startMenu.style.display = "flex";
    msg.style.display = "block";

    if (document.pointerLockElement === canvas) {
        document.exitPointerLock?.();
    }
}


// Main loop
function loop(){
    requestAnimationFrame(loop);
    if(!gameStarted || paused) return;
    if(!gameOver && !gameWin){
        movePlayer();
        if(fireCooldown>0) fireCooldown--;
        if(shooting && fireCooldown<=0){
            shootEnemies();
            fireCooldown = 10; // player fire rate; tweak if you want faster/slower
        }
        updateBullets();
        updateEnemyBullets();
        collectHealthPacks();
	collectOneUps();

    }
    castRays();
    //drawOneUps2D();
    //drawItemsAndCar(); // draw collectibles and car 
    drawItemsAndCar3D(zBuffer); // draw collectibles and car   
    drawHealthPacks3D();
    drawOneUps3D(); 
    drawEnemies();
    drawBullets();
    drawEnemyBullets();
    drawGun();
    drawStatusBar();
    //drawMiniMap();
    //drawHealthPacks2D();



              
    updateHUD();
    checkEndConditions();
    drawEndOverlay();

    if(tempMsgTimer > 0){
    const w = canvas.width, h = canvas.height;
    ctx.save();
    ctx.textAlign = "center";
    ctx.font = "32px Consolas";
    ctx.fillStyle = "#0ff";
    ctx.shadowColor = "#000";
    ctx.shadowBlur = 10;
    ctx.fillText(tempMsg, w/2, h/2);
    ctx.restore();
    tempMsgTimer--;
    }

}
loop();

// Pause music if leaving page
document.addEventListener("visibilitychange", ()=>{ if(document.hidden) bgMusic.pause(); else if(gameStarted && !gameOver && !gameWin) bgMusic.play().catch(()=>{}); });

// ESC fallback
document.addEventListener("keydown",(e)=>{ if(e.key==="Escape" && !gameStarted){ resetToMenu(); } });
</script>
</body>
</html>



